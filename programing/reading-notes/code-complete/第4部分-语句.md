# 第4部分 语句

## 第14章 组织直线型代码

### 14.1 必须有明确顺序的语句

* 设法组织代码，使依赖关系变得非常明显
* 使子程序名能凸显依赖关系
* 利用子程序参数明确显示依赖关系
* 用注释对不清晰的依赖关系进行说明
* 用断言或者错误处理代码来检查依赖关系

### 14.2 顺序无关的语句

* 使代码易于自上而下地阅读
* 把相关的语句组织在一起

## 第15章 使用条件语句

### 15.1 if 语句

#### 简单 if-then语句

* 首先写正常代码路径，再处理不常见情况
* 确保对于等量的分支是正确的
* 把正常情况的处理放在if后面而不要放在else后面
* 让if子句后面跟随一个有意义的句子
* 考虑else子句

#### if-then-else语句串

* 利用布尔函数简化复杂的检测
* 把最常用的情况放在最前面
* 确保所有的情况都考虑到了
* 如果你的语言支持，请把if-then-else语句串替换成其它结构

### 15.2 case语句

为case语句选择最有效的排列顺序：

* 按字母顺序或按数字顺序排列各种情况
* 把正常的情况放在前面
* 按执行频率排列case子句

使用case语句的诀窍：

* 简化每种情况对应的操作：可以使用子程序
* 不要为了使用case语句而刻意制造一个变量
* 把default子句只用于检查真正的默认情况
* 利用default子句来检测错误
* 在C++和Java里，避免代码执行越过一条case子句的末尾（显式的break）
* 在C++里，在case末尾明确无误地标明需要穿越执行的程序流程

### 第16章 控制循环

### 16.1 选择循环的种类

* 计数循环
* 连续求值的循环
* 无限循环
* 迭代器循环

什么时候使用while循环

* 检测位于循环的开始
* 检测位于循环的结尾

什么时候用带退出的循环？

正常的带退出的循环：如果把循环条件检测放在循环开始或结束处，那就需要写一个半循环的代码（在循环开始前或结束后需要循环体的重复代码）

何时使用for循环：执行次数固定的循环

合适使用foreach循环：数组或容器的迭代操作

### 16.2 循环控制

应该把循环看做是一个黑盒子

进入循环

* 只从一个位置进入循环
* 把初始化代码紧放在循环前面
* 用`while(true)`表示无限循环
* 在适当情况下多使用for循环
* 在while循环更适用的时候，不要使用for循环

处理好循环体

* 用 {} 把循环体中的语句括起来
* 避免空循环
* 把循环内务操作要么凡在循环的开始，要么放在循环的末尾
* 一个循环只做一件事

退出循环

* 设法确认循环能够终止
* 使循环终止条件看起来很明显
* 不要为了终止循环而胡乱改动for循环的下标
* 避免出现依赖于循环下标最终取值的代码
* 考虑使用安全计数器

提前退出循环

* 考虑在while循环中使用break语句而不用布尔标记
* 小心那些有很多break散布其中的循环
* 在循环开始处用continue进行判断
* 如果语言支持，请使用带标号break结构
* 使用break和continue时要小心谨慎

检查端点

* 开始的情况
* 任意选择的中间情况
* 最终的情况

使用循环变量

* 用整数或者枚举类型表示数组和循环的边界
* 在嵌套循环终宏使用有意义的变量命来提高其可读性
* 用有意义的名字来避免循环下标串话
* 把循环下标变量的作用域限制在本循环内

循环应该有多长

* 循环要尽可能地短，以便能够一目了然
* 把嵌套限制在3层以内
* 把长循环的内容移到子程序里
* 要让长循环格外清晰

### 16.3 轻松创建循环——由内而外

从一种情况开始，用字面量来编写代码，然后缩进它，在外面加一个循环，然后用循环下标或计算表达式替换那些字面量。如果需要，在它的外面再套上一个循环，然后再替换掉一些字面量。

### 16.4 循环和数组的关系

有些语言是支持直接的数组运算的，从而可以减少循环

## 第17章 不常见的控制结构

### 17.1 子程序中的多处返回

* 如果能增强可读性，那么就使用return
* 用防卫子句（早返回或早退出）来简化复杂的错误处理
* 减少每个子程序中return的数量

### 17.2 递归

* 确认递归能够停止
* 使用安全计数器防止出现无穷递归
* 把递归限制在一个子程序内
* 留心栈空间
* 不要用递归去计算阶乘或者斐波拉契数列

### 17.3 goto

* 在那些不直接支持结构化控制语句的语言里，用goto模拟那些控制结构
* 如果语言内置了等价的控制结构，那么就不要用goto
* 如果是为了提高代码效率而是用goto，请衡量此举实际带来的性能提升
* 除非你要模拟结构化语句，否则尽量在每个子程序只使用一个goto标号
* 除非你要模拟结构化语句，否则尽量让goto向前跳转而不要向后跳转
* 确认所有goto标号都被用到了
* 确认goto不会产生某些执行不到的代码

## 第18章 表驱动法

### 18.1 表驱动法使用总则

从表里面查找信息而不使用逻辑语句，使用表驱动法的两个问题：

* 怎样从表中查询条目：直接访问，索引访问，阶梯方位
* 应该在表里存些什么：数据，动作（代码/函数指针）

### 18.2 直接访问表

如何构造查询键值：

* 复制信息从而能够直接使用键值
* 转换键值以使其能够直接使用
* 把键值转换提取成独立的子程序

### 18.3 索引访问表

先用一个基本类型的数据从一张索引表中查出一个键值，然后用这一键值查出你感兴趣的主数据，优点：

* 节省内存空间
* 操作位于索引中的记录更廉价
* 可维护性

### 18.4 阶梯访问表

表中的记录对于不同的数据范围有效，而不是对于不同的数据点有效。把每一个区间的上限写入一个表里，然后循环按照各区间的上限来检查分数。

* 留心端点
* 考虑用二分查找取代顺序查找
* 考虑用索引访问来取代阶梯技术
* 把阶梯表查询操作提取成单独的子程序

## 第19章 一般控制问题

### 19.1 布尔表达式

* 用true和false做布尔判断，隐式地比较布尔值与true和false
* 简化复杂地表达式
  * 拆分复杂的判断并引入新的布尔变量
  * 把复杂的表达式做成布尔函数
  * 用决策表代替复杂的条件
* 编写肯定形式的布尔表达式
* 用括号使布尔表达式更清晰
* 理解布尔表达式时如何求值的，注意短路
* 按照数轴的顺序编写数值表达式
* 与0比较的指导原则
  * 隐式地比较逻辑变量
  * 把数与0相比较
  * 在C中显式地比较字符和零终止符`(\0)`
  * 把指针与NULL相比较
* 布尔表达式地常见问题
  * 在C家族语言中，应该把常量放在比较地左端
  * 在C++中，刻意考虑创建预处理宏来替换&&， ||和==
  * 在Java中，应理解a==b和a.equals(b)之间的差异

### 19.2 复合语句（语句块）

* 把括号一起写出
* 用括号来把条件表达清楚

### 19.3 空语句

* 小心使用空语句
* 为空语句创建一个DoNothing()预处理宏或者内联函数
* 考虑如果换用一个非空的循环，是否会让代码更清晰

### 19.4 驯服危险的深层嵌套

* 通过重复检测条件中的某一部分来简化嵌套的if语句
* 用break块来简化嵌套if
* 把嵌套if转换成一组if-then-else语句
* 把嵌套if转换成case语句
* 把深层嵌套的代码抽取出来放进单独的子程序
* 使用一种更加面向对象的方法
* 重新设计深层嵌套的代码

### 19.5 编程基础：结构化编程

一个应用程序应该只采用一些单入单出的控制结构

* 顺序
* 选择
* 迭代

### 19.6 控制结构与复杂度

降低程序的复杂度，以及为了理解它所需要的专心程度。