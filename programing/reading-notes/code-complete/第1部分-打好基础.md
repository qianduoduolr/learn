# 代码大全

## 什么是代码大全？

代码大全是一本书，讲的是如何写代码，与具体的编程语言无关，而是以方法论为主，很厚，九百多页的砖头。

2008年的时候，我在成都某新华书店第一次看到一本叫《代码大全》的书，我还以为是一本摘抄了各种代码的类似《食谱大全》的书，因此都懒得去翻开看一下，因为觉得抄代码有互联网就足够了，这件事可能说明了两个问题：

- “代码大全”这个书名翻译得太烂；
- 我当年很无知。

《Code Complete》实在是应该翻译为《代码完成》比较合适，据第二版的译者说，因为第一版翻译为《代码大全》，他们也只好将错就错。市面上的计算机类书籍汗牛充栋，大多是针对具体编程语言的，要不就是讲需求分析、软件设计、软件测试，直接讲软件构建的书反而很少，很多人也学了一些软件工程的皮毛，但是代码写出来还是不忍卒读，用本书的观点来说，只有软件构建——直白一点说叫写代码，才是一个程序员才会确实去做的事，至于其他部分，往往都伴随着谎言。

俗话说“走都不会走，还想学跑？”，一个程序员，先老老实实把自己写代码的水平提高，实在是最基本也最重要的，在学校教育经历中，一般人写的都是“一次运行，用完就扔”的学生代码，与做软件产品的要求相距甚远，而这本书，在教你怎么把代码写好这方面，真是事无巨细，处处闪耀着真知灼见，从这个角度来看，叫它大全，也不为错。比如我的编程入门教材是谭浩强的《C程序设计》，里面的变量命名风格是单字母风格，而本书则花了一章来讲变量名的问题，对于单字母门派出来的人，实在是一剂良药。

我从大概2015年买了本英文版读，读了5章后停下来，直到今年（2019）把中文版读完，而这本书的英文版出版于2003年。十几年过去了，书中很多方法论已经是业界公论。但方法论说得溜是当代程序员的特点，而实践水平倒是不见得有什么提升，热衷于谈框架、谈机器学习，但好的代码依然少见。

这份笔记会补充一些我自己近年的思考与近年的技术方法。

# 第1部分 打好基础

所谓磨刀不误砍柴功，要做什么是一个看似简单，实则复杂的问题。

## 第1章 欢迎进入软件构建的世界

一般软件工程的书会把过程划分的很清楚，软件开发的活动包括：

- 问题定义
- 需求开发
- 构建计划
- 软件架构
- 详细设计
- 编码和调试
- 单元测试
- 集成测试
- 集成
- 系统测试
- 修正维护

代码构建的核心是编码和调试，为了编码和调试，会或多或少牵涉到其他活动，非正式开发的时候，我们可能直接坐下来敲代码，上面的所有活动都打包了。而软件构建，讲的大概是敲代码的时候干的那些事情，你如果真的敲过代码，就知道大部分时间其实你是对着屏幕发呆状而不是在敲键盘（只有电影里的黑客才不听的噼里啪啦敲键盘），要做的事情包括：

- 检查准备工作是否已经做好，可以安心敲代码了
- 想好如何测试代码
- 设计和实现类和函数
- 创建变量和命名常量
- 选择控制结构，组织语句
- 单元测试，集成测试，调试代码
- 相互Review代码
- 通过格式化和好的注释来打磨代码
- 集成分别开发的组件
- 修改代码使其运行更快占用资源更少

为什么软件构建很重要？

- 软件构建是软件开发的主要活动——大部分时间都在码代码
- 软件构建是软件开发的中心活动——没有代码，再多的文档都是扯淡
- 关注软件构建可以极大提高每个程序员的生产力——大部分的程序员基本功不过关
- 软构建的产品——代码，经常是软件唯一精确的描述——文档都是骗人的
- 软件构建是唯一保证会做的工作——再懒也不能用PPT开发

## 第2章 用隐喻来更充分地理解软件开发

### 2.1 隐喻(Metaphors)的重要性

人类理解事物是从已知到未知的，作者举了科学史上很多例子说明metaphor的重要性，我觉得，能打好一个比方其实是很难的，善于打比方的人是最聪明的一类人，这可能需要大脑回路比较丰富才行。对一个事物理解越深刻，想出来的比喻就会越贴切，或者说模型就会越精确。

### 2.2 如何使用软件的隐喻

比喻不是算法，不会给出明确的指引，而是具有启发性的，会引导你思考的方向。

- 帮你洞察问题和处理
- 帮你找到更好的做事情的方式

### 2.3 一般的软件隐喻

#### 软件书写：写代码

写代码这个说法很常见，是借喻写文章而来的，这种借喻有很多不恰当的地方，比如代码更易于修改，基本上很难有“完成”的一天，代码不强调原创而强调复用。

基本上，这是一个糟糕的借喻，只对写很小的软件适用。

#### 软件农场：种植系统

软件系统确实有不断增长的一面，但却不是播了种子施肥浇水等收获的概念。

#### 软件牡蛎农场：系统增生

这个隐喻说的是渐进增强，像牡蛎一样，在沙粒上一层层裹碳酸钙，最后长成珍珠。这个概念近年来越来越火了，不单软件工程提，关于创业的理论也提。我个人的体会是：对需求不明的项目，一个基本的初步实现是讨论的基础，也是信心的来源。

#### 软件构建：建造软件

这是最重要的一个隐喻了，它源自建筑行业，开发软件和修建筑有很多相似点

- 复杂度和尺寸的影响很大
- 复用，而不是从头实现
- 个性化定制
- 好的规划能让后续细节的调整更容易
- 不同的项目使用不同的方法
- 越晚修改代价越大
- 对超大型项目，动手构建前的准备极为重要

#### 应用软件技术：智力工具箱

工具箱是一个很好的比喻，以免我们迷失在某个方法论或技术中，“拿个锤子，看什么都像钉子”，好的匠人，必然是有一个好的工具箱的，面对具体的情况，使用不同的工具。一个程序员应当不断扩充自己的工具箱。

#### 合成隐喻

隐喻是启发式的，只要有利于说明我们的问题，都没有必要拒绝。

## 第3章 三思而后行：前期准备

不同规模的构建，需要不同程度的准备工作，项目的成败，早已埋下伏笔。构建一般占项目时间的65%，而糟糕的准备工作会让构建时间增加两三倍。

### 3.1 前期准备的重要性

高质量的软件来自高质量的实践，如何保证质量？

- 前期：关注需求、设计。
- 中期：关注构建。
- 后期：关注测试。

本书重点关注中期，但是在开始构建之前，需要弄清前期准备做到了什么程度，贸然开场容易悲剧。

#### 现代软件开发是否需要前期准备？

需要。前期准备可以降低风险，不同的项目可能需要不同的前期准备实践，但不能没有。

#### 不完整的前期准备的理由

- 开发者没有经验——那就去学啊。
- 按捺不住写代码的心——多碰几次壁。
- 上级让你赶紧写代码！——拒绝上级；假装在编程；教育上级；跳槽。

#### 构建之前做好前期准备的理由

你可以拿它来教育别人。

##### 诉诸逻辑

- 需要弄清楚到底想构建个啥。
- 需要弄清楚怎么去构建系统。

##### 诉诸类比

- 造房子
- 软件开发食物链：程序员在食物链尽头。

##### 诉诸数据

- 最后阶段更改的代价是10~100倍。

##### 老板敏捷测试

自我实现预言：

- 我们必须立即开始编码因为还有很多调试工作要做。
- 我们没有计划多少时间去测试因为不会找到太多的缺陷。
- 我们充分研究了需求和设计，在编码和调试的时候不会遇到大的问题。

### 3.2 确定你开发的软件类型

针对不同的软件类型，需要不同的生命周期模型:

- 商业系统
- 关键任务系统
- 嵌入式性命攸关系统

#### 迭代方法在前期准备中的作用

- 先做80%的需求分析，则类似串行
- 先做20%的需求分析，则类似迭代

#### 在迭代方法与串行方法间的选择

- 需求是否明确？
- 设计是否复杂？
- 团队对领域是否熟悉？
- 项目风险大不大？
- 更改需求、设计的代价如何？

### 3.3 问题定义

- 好的问题定义弄清楚问题是什么，而不要考虑实现。
- 问题定义在需求分析之前，使用用户语言描述。
- 最好的解决方案可能不需要写软件。
- 除非是为了解决计算机系统问题，否则不使用计算机语言。
- 问题定义出错的代价：浪费了时间，没有解决真正的问题。

### 3.4 需求分析

需求分析讨论软件怎么解决问题，是解决方案的第一步。

#### 为什么需要正式的需求？

- 确保用户而非程序员决定系统功能，程序员明确知道用户需要什么。
- 避免争吵，以需求为准。
- 好的需求会减少开始构建后的变更。

#### 稳定需求的神话

稳定的需求是软件开发的圣杯。

- 用户往往不能准备描述需求。
- 只有充分使用系统，才能深入理解系统。
- 开发过程会使用户更好的理解系统，这也是需求变更的主要来源。
- 典型的系统会有25%的需求变更，花费70%~85时间重做。

#### 在构建时应对需求变化

- 检查需求分析的质量，如有问题，尽早返工。
- 确保每个人明白需求变更的代价，正确应对“特性中毒者”。
- 建立变更控制过程，做到程序员顾客都满意。
- 使用能适应需求变更的开发方法：原型进化、渐进交付、小开发周期。
- 放弃项目。
- 始终关注项目的商业价值。

### 3.5 架构设计

架构设计，一般对应“概要设计文档”，架构决定了系统的“概念完整”。架构设计进行工作分解，直至程序员可以上手工作。

## 第4章 关键构建决策

### 4.1 选择编程语言

语言选择事关效率，语言熟悉——效率高30%，熟练工——3倍效率。一定程度上，思想表达能力取决于词汇量。 表达能力：C,1;C++,2.5;Python,6. 不要使用了一门新的语言，却不使用它好的机制，还是完全用旧语言的模式编程。 语言描述：

- Ada 数据抽象，信息隐藏，用于军队、航空航天。
- 汇编 处理器相关，代码体积或速度有严格限制时应用。
- C 普适，中等语言，可移植的汇编（指针、地址、位运算、弱类型），高级特性：结构体，控制流，机器独立，丰富的运算符。
- C++ C基础上的面向对象语言，类、多态、异常处理、模板、类型控制、标准库
- C# 类似C、C++、Java（个人认为C#语言本身是很优秀的，融合了部分函数式编程的思想，但是社区支持比Java略差）
- Cobol 通用商业语言（银行还在用）。
- Fortran 最早的高级语言之一，过去科学计算和教学比较多使用（现在Python用得更多吧）。
- Java （最早的虚拟机语言，社区庞大。）
- JavaScript （无处不在了）
- Perl 擅长字符处理（跟Python不同的哲学）
- PHP （世界上最好的语言😀）
- Python （万能胶水，随着机器学习而变成了显学）
- SQL 结构化查询语言，主要用于数据库。
- Visual Basic （拉控件编程的经典）

最近几年的新语言：

* go C++替代之一，代表作品docker
* rust C++替代之二
* dart JavaScript 替代之一，用于框架flutter

### 4.2 编程约定

高层的架构与底层实现要保持一致，统一的规范不但利于团队合作，还可以解放脑力。

### 4.3 你在技术浪潮中的位置

处在一个技术的早期，风险与额外的收益并存，技术成熟期则风险小，中规中矩。 注意Program in a language 和 Program **into** a language的区别，语言提供了工具箱，但是不要局限于语言的工具箱。

如果能多学一些语言，再融汇贯通，就能理解语言的精髓，而不局限于语言。可参考：

*  [Programming Languages 公开课](https://www.coursera.org/learn/programming-languages)
* [七周七语言]( https://www.ituring.com.cn/book/829 )
* [代码之髓]( https://www.ituring.com.cn/book/1233 )

### 4.4 选择你主要的构建实践

当前针对各种编程语言，一般都会有最佳实践一类的东西，或者有优秀的开源项目作为参考，总之刚开始不要自己摸索，用前人的最佳实践做几个项目之后再考虑根据自己的需要做优化。

做好最佳实践，能够把自己的精力集中到代码的逻辑中去，减轻代码管理、调试等工作的复杂性。