# 第3部分 变量

## 第10章 使用变量的一般事项

### 10.1 数据认知

### 10.2 轻松掌握变量定义

* 关闭隐式声明
* 声明全部的变量
* 遵循某种命名规则
* 检查变量名

### 10.3 变量初始化原则

* 在声明变量的时候初始化
* 在靠近变量第一次使用的位置初始化它
* 理想情况下，在靠近第一次使用变量的位置声明和定义该变量
* 在可能的情况下使用final或者const
* 特别注意计数器和累加器
* 在类的构造函数里初始化该类的数据成员
* 检查是否需要重新初始化
* 一次性初始化具名常量，用可执行代码来初始化变量
* 使用编译器来设置自动初始化所有变量
* 利用编译器的警告信息
* 检查输入参数的合法性
* 使用内存访问检查工具来检查错误的指针
* 在程序开始时初始化工作内存

### 10.4 作用域

作用域指的是变量在程序内的可见和可引用的范围

#### 使变量引用局部化

#### 尽可能缩短变量的存活时间

#### 减少作用域的一般原则

* 在循环开始之前再去初始化该循环里使用的变量，而不是在该循环所属的子程序的开始处初始化这些变量
* 直到变量即将被使用时再为其赋值
* 把相关语句放在一起
* 把相关语句组提取成单独的子程序
* 开始时采用最严格的可见性，然后根据需要扩展变量的作用域

#### 有关缩小变量作用域的说明

“方便性”与“智力上的可管理性”的权衡

### 10.5 持续性

持续性的多种形态

* 特定代码段或子程序的生命期
* 只要你允许，他就会持续下去
* 程序的生命期
* 永远持续

### 10.6 绑定时间

把变量和它的值绑定在一起的时间

* 编码时
* 编译时
* 加载时
* 对象实例化时
* 即时

### 10.7 数据类型和控制结构之间的关系

* 序列型数据翻译为程序中的顺序数据
* 选择型数据翻译为程序中的if和case语句
* 迭代型数据翻译成程序中的for、repeat、while等循环结构

### 10.8 为变量指定单一用途

* 每个变量只用于单一用途
* 避免让代码具有隐含含义
* 确保使用了所有已声明的变量

## 第11章 变量名的力量

### 11.1 选择好的变量名的注意事项

#### 最重要的命名注意事项

要完全、准确地描述出该变量所代表的事物。

#### 以问题为导向

一个好记的名字反映的通常都是问题，而不是解决方案。

#### 最适当的名字长度

10~16个字符，8~20个字符，注意不要教条

#### 作用域对变量名的影响

* 作用域越大，倾向于用越长的变量名
* 对于全局命名空间中的名字加以限定词

#### 变量名中的计算值限定词

Total、Sum等限定词放到名字的最后

#### 变量名中的常用对仗词

建议成对使用

### 11.2 为特定类型的数据命名

#### 为循环下标命名

i, j, k

#### 为状态变量命名

不要用一般性的flag，不要猜测变量名的含义

#### 为临时变量命名

警惕临时变量，使用比temp更有含义的命名

#### 为布尔变量命名

* 谨记典型的布尔变量命：done， error，found，success或ok
* 给布尔变量赋予隐含真/假含义的名字
* 使用肯定的布尔变量名

#### 为枚举类型命名

* 如语言不支持类似类的处理，自己加上前缀

#### 为常量命名

使用常量的含义而不是数值命名

### 11.3 命名规则的力量

#### 为什么要有规则

* 要求你更多地按规矩行事
* 有助于在项目之间传递知识
* 有助于你在新项目中更快速的学习代码
* 有助于减少名字增生
* 弥补编程语言的不足之处
* 强调变量之间的关系

#### 何时采用命名规则

合作/正式/长期的项目

#### 正式程度

取决于项目规模/生命周期

### 11.4 非正式命名规则

#### 与语言无关的命名规则指导原则

* 区分变量名和子程序名字
* 区分类和对象
* 标识全局变量
* 标识成员变量
* 标识类型声明
* 标识具名常量
* 标识枚举类型的元素
* 在不能保证输入参数只读的语言标识只读参数
* 格式化命名以提高可读性

### 11.5 标准前缀

* 用户自定义类型缩写
* 语义前缀

### 11.6 创建具备可读性的短名字

* 不要用从每个单词删除一个字符的方式来缩写
* 缩写要一致
* 创建你能读出来的名字
* 避免使用容易看错或者读错的字符组合
* 使用辞典来解决命名冲突
* 在代码里用缩写对照表来解释极短的名字的含义
* 在一份项目级的标准缩写文档中说明所有的缩写
*  名字对于代码读者的意义比作者更重要

### 11. 7 应当避免的名字

* 避免使用令人误解的名字或缩写
* 避免使用具有相似含义的名字
* 避免使用具有不同含义但却有相似名字的变量
* 避免使用发音相近的名字
* 避免在名字中使用数字
* 避免在名字中拼错单词
* 避免似乎用英语中常常拼错的单词
* 不要仅靠大小写来区分变量命
* 避免使用多种自然语言

* 避免使用标准类型、变量和子程序的名字
* 不要使用与变量含义完全无关的名字
* 避免在名字中包含易混淆的字符

## 第12章 基本数据类型

### 12.1 数值概论

* 避免使用硬编码的“神秘数字”
* 如果需要，可以使用硬编码的0和1
* 预防除零错误
* 使类型转换变得明显
* 避免混合类型的比较
* 注意编译器的警告

### 12.2 整数

* 检查整数除法
* 检查整数溢出
* 检查中间结果溢出

### 12.3 浮点数

* 避免数量级相差巨大的数之间的加减运算
* 避免等量判断
* 处理舍入误差问题
* 检查语言和函数库对特定数据类型的支持

### 12.4 字符和字符串

* 避免使用神秘字符和神秘字符串
* 避免off-by-one错误
* 了解你的语言和开发环境是如何支持Unicode的
* 在程序生命期中尽早决定国际化/本地化策略
* 如果你知道只需要支持一种文字的语言，请考虑使用ISO 8859字符集
* 如果你需要支持多种语言，请使用Unicode
* 采用某种一致的字符串类型转换策略

C语言中的字符串

* 注意字符串指针和字符数组之间的差异
* 把C-style字符串的长度声明为CONSTANT + 1
* 用null初始化字符串以避免无结束符的字符串
* 用字符数组取代C中的指针
* 用字符串子程序的安全版本， `strlcpy()`或`strcpy_s()`

### 12.5 布尔变量

* 用布尔变量对程序加以文档说明
* 用布尔变量来简化复杂的判断
* 如果需要的话，创建自己的布尔类型

### 12.6 枚举类型

* 用枚举类型来提高可读性
* 用枚举类型来提高可靠性
* 用枚举类型来简化修改
* 用枚举类型作为布尔变量的替换方案
* 检查非法值
* 定义处枚举的第一项和最后一项，以便于循环边界
* 把枚举类型的第一个元素留做非法值
* 明确定义项目代码编写标准中第一个和最后一个元素的使用规则，并且在使用时保持一致
* 警惕给枚举元素明确赋值而带来的失误

#### 如果你的语言里没有枚举类型

可以自己设法用全局变量的规范或者类来模拟。

### 12.7 具名常量

* 在数据声明中使用具名常量
* 避免使用文字量，即使是安全的
* 用具有适当作用域的变量或类来模拟具名常量
* 统一地使用具名常量

### 12.8 数组

* 确认所有的数组下标都没有超出数组地边界
* 考虑用容器来取代数组，或者将数组作为顺序化结构来处理
* 检查数组地边界点
* 如果数组是多维的，确认下标的使用顺序是正确的
* 提防下标串话
* 在C中结合`ARRAY_LENGTH()`宏来使用数组

### 12.9 创建你自己的类型（类型别名）

* 易于修改
* 避免过多的信息分发
* 增加可靠性
* 弥补语言的不足

指导原则：

* 给所创建的类型取功能导向的名字
* 避免使用预定义类型
* 不要重定义一个预定义的类型
* 定义替代类型以便于移植
* 考虑创建一个类而不是typedef

## 第13章 不常见的数据类型

### 13.1 结构体

* 用结构体来明确数据关系
* 用结构体简化对数据块的操作
* 用结构体来简化参数列表
* 用结构体来减少维护

### 13.2 指针

理解指针的关键：

* 内存中的位置
* 如何解释指针所指的内容

使用指针的一般技巧：

* 把指针操作限制在子程序或者类里面
* 同时声明和定义指针
* 在指针分配相同的作用域中删除指针
* 在使用指针之前检查指针
* 先检查指针所引用的变量再使用它
* 用狗牌字段来检查损毁的内存
* 增加明显的冗余
* 用额外的指针变量来提高代码清晰度
* 简化复杂的指针表达式
* 按照正确的顺序删除链表中的指针
* 分配一片保留的内存后备区域
* 粉碎垃圾数据
* 再删除或者释放指针后把它们设为空值
* 在删除变量之前检查非法指针
* 跟踪指针分配情况
* 编写覆盖子程序，集中实现避免指针问题的策略
* 采用非指针的技术

#### C++指针

* 理解指针和引用之间的区别
* 把指针用于“按引用传递”参数，把const引用用于“按值传递”参数
* 使用 `shared_ptr`
* 灵活运用智能指针

#### C指针

* 使用显式指针类型而不是默认类型
* 避免强制类型转换
* 遵循参数传递的星号规则
* 在内存分配中使用`sizeof()`确定变量的大小

### 13.3 全局数据

常见问题：

* 无意间修改了全局数据
* 与全局数据有关的别名问题
* 与全局数据有关的代码重入问题
* 全局数据阻碍代码重用
* 与全局数据有关的非确定的初始化顺序事宜
* 全局数据破坏了模块化和质量上的可管理性

使用全局数据的理由：

* 保存全局数据
* 模拟具名常量
* 模拟枚举类型
* 简化对及其常用的数据使用
* 消除流浪数据

只有万不得已时才使用全局数据

* 首先把每一个变量设置为局部的，仅当需要时才把变量设置为全局的
* 区分全局变量和类变量
* 使用访问器子程序
  * 要求所有的代码通过访问器子程序来存取数据
  * 不要把你所有的全局数据扔在一处
  * 用锁定来控制对全局变量的访问
  * 在你的访问器子程序里构建一个抽象层
  * 使得对一项数据的所有访问都发生在同一个抽象层

如何降低使用全局数据的风险：

* 创建一种命名规则来突出全局变量
* 为全部的全局变量创建一份注释良好的清单
* 不要用全局变量来存放中间结果
* 不要把所有的数据都放在一个大对象中并到处传递，以说明你没有使用全局变量