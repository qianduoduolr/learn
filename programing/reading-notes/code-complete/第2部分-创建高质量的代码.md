# 第2部分 创建高质量的代码

## 第5章 构建中的设计

设计不太可能在构建之前完成。

### 5.1 设计挑战

- 设计是一个邪恶的(wicked)问题：只能通过解决这个问题或部分解决问题才能清楚的定义这个问题。这是 真正的程序和学生作业的区别。
- 设计是一个草率的过程：会犯错；好的方案很精妙；“足够好”很难定义。
- 设计关乎权衡和优先级
- 设计牵涉约束
- 设计是非决定性的：有很多途径
- 设计是一个启发式的过程：没有银弹
- 设计是自然发生的

### 5.2 关键设计概念

#### 软件的首要技术法则：管理复杂性

* 偶然的和本质的困难: 此划分来自亚里士多德的哲学。 偶然的：笨拙的语法、非交互式的计算机、难以一起工作的工具； 本质的：与真实世界复杂、无序的接口，异常情况，精确性，准确定义真实世界如何运行。

* 管理复杂性的重要性失败的原因：糟糕的需求/计划/管理，失控的复杂性管理。 程序太大，人类无法一次性理解。问题分级后易于理解（如包管理），保持从程序短小，写代码时考虑人类的极限。
* 如何消灭复杂性：减少每个人脑中需要一次性处理的固有复杂性；防止不必要复杂性的增殖。

#### 理想的设计特征

- 最小复杂度：聪明的 vs 简单易维护的。
- 易维护：为代码维护者编程，自解释的设计。
- 松耦合：不同部分之间的联系尽量少。
- 可扩展性：更改时减少创伤。
- 可复用性
- 高扇入：充分复用底层模块
- 低扇出：不过度依赖其他部分
- 可移植性
- 精简：没有多余部分
- 分层化：隔离变化
- 标准技术：不要用古怪的技术

#### 设计的层次

1. 软件系统
2. 子系统或包：子系统间的通信必须加以限制，否则会不断熵增，一片混乱，可以先紧后松。常见的子系统：商业规则、用户接口、数据存取、系统依赖。
3. 类：包括接口。大项目由子系统划分，定义一些外部函数；小项目由系统直接划分。
4. 例程：可能会引起第3层的修改。
5. 例程内设计

### 5.3 设计建造的砖块：启发式

一个不断试错的过程。

#### 找到现实世界的对象

- 标识对象和其属性
- 决定改对象能干啥
- 决定每个对象能对其他对象干啥
- 决定对象各部分的可见性
- 决定对象的公开接口

一个迭代过程：重新组织，类的细节修改。

#### 组织一致的抽象

在不同的层次忽略细节。集合=>抽象。基类、接口。

- 函数层次
- 类层次
- 包或子系统层次

#### 封装实现细节

#### 继承——当继承简化设计时使用

#### 信息隐藏

- 结构化设计：黑盒
- 面向对象设计：封装、模块化、抽象

##### 秘密和隐私权

##### 两种策略

- 隐藏复杂性使你的大脑不需要考虑它，除非特别关注时
- 隐藏更改源，隔离变化

##### 信息隐藏的障碍

- 分布过广的信息
- 环形依赖
- 不当的全局数据
- 担心性能损失

##### 信息隐藏的价值

启发性的力量，设计好的公共接口。问正确的问题：这个类需要隐藏什么？

#### 标示易变区域

标示=>分割=>隔离

- 商业规则
- 硬件依赖
- 输入输出
- 非标准语言特性
- 设计和构建困难的区域
- 状态变量：使用枚举代替bool值；使用存取函数代替直接访问。
- 数据大小限制

##### 预期不同程度的变化

先找出最小子集，再做功能性、质量性改进。

#### 保持松耦合

##### 耦合标准

- 大小：模块间联系的数量，如函数的参数个数，类的公开方法数量；
- 可见性：明确引用，胜过更改全局变量。
- 可变性：容易改变连接，被不同的模块调用。

##### 耦合的种类

- 简单数据参数耦合：模块间传递了简单数据类型。常见、可接受。
- 简单对象耦合： 一个对象初始化了另一个对象。合理。
- 对象参数耦合：对象1需要对象2向其传递对象3。耦合较紧密。
- 语义耦合
  - 模块1传递了一个标志给模块2，告诉模块2应该去干啥。如果模块2定义了一个数据类型来表示该标志，则合理。
  - 模块2使用模块1更改过的全局变量。有时序假设，不好。
  - 模块1在调用某函数前必须先调用初始化函数。
  - 模块1传递对象给模块2，知道模块2将使用对象的部分方法，只对对象进行部分初始化。
  - 模块1传递基类给模块2，模块2知道模块1实际传递的是派生类，强制转化后使用。

危险:使用了编译器无法检测的方法使用别的类。 一旦使用了，你就得自己负责正确性。

#### 寻找一般的设计模式

- 模式通过已经准备好的抽象来降低复杂性
- 模式使一般解决方案制度化以减少错误
- 模式通过建议设计选择提供启发性价值
- 模式通过提升设计语言测层次使沟通更流畅

#### 其他的启发式方法

- 高内聚
- 构建继承体系
- 正式化类协议
- 职责分配
- 为测试设计
- 避免失败
- 有意识的选择绑定时间
- 使控制点集中
- 使用暴力方法
- 画图示
- 保持设计模块化

#### 启发性方法指导

```
 Polya's How to Solve It 
```

不要卡在一个小问题上，你不需要一次性解决所有的设计问题。

### 5.4 设计实践

#### 迭代

发现不顶用的设计。

#### 分治

#### 自顶向下与自底向上

两种方法论应当结合使用。自顶向下容易入手，但是有时底层的复杂性会影响到上层；自底向下难入手，但是能及早的管理复杂性，使得上层设计更容易。

#### 试验原型

#### 协作设计

- 起身去问协作者
- 和协作者坐在一起用白板讨论草图
- 结对编程
- 开会向其他协作者讲解设计
- 正式的审查
- 冷处理自己的设计，再回头看
- 求助公司外的人，在论坛上提问

#### 多少设计才足够？

一般来说，越细越好；设计文档不是越多越好。

#### 记录你的设计工作

- 在代码中插入设计文档
- 在Wiki中记录设计的讨论和决定
- 写e-mail总结
- 拍照
- 保存设计海报
- 使用“类-职责-协作”卡片
- 在适当的细节层次使用UML图

### 5.5 对流行方法学的评论

不要过多关注设计方法学，关注设计本身，不设计或事无巨细的设计都不可取，还是要具体情况具体分析。

## 第6章 可以工作的类

### 6.1 类的基础：抽象数据类型(ADTs)

一些数据以及对这些数据操作的集合。ADT是类的基础，但不一定以类的形态存在。

使用ADT的益处：

* 可以隐藏实现细节
* 改动不会影响到整个程序
* 让接口能提供更多信息
* 更容易提高性能
* 让程序的正确性显而易见
* 程序更具自我说明性
* 无须在程序内到处传递数据
* 你可以像在现实世界中那样操作实体

ADT示例：

* 把常见的底层数据类型创建为ADT并使用这些ADT，而不再使用底层数据类型
* 把像文件这样的常用对象当成ADT
* 简单的事物也可以当作ADT
* 不要让ADT依赖于其存储介质

在非面向对象环境中用ADT处理多分数据实例（比如C语言）：

1. 每次使用ADT服务子程序时都明确指定实例（使用id）
2. 明确地向ADT服务子程序提供所要用地数据
3. 使用隐含实例（需要跟踪当前实例，容易出错）

类=ADT+继承+多态

### 6.2 良好的类接口

* 展现一致的抽象层次
* 理解类所实现的抽象是什么
* 提供成对的服务
* 把不相关的信息转移到其他类中
* 尽可能让接口可编程，而不是表达语义（编译器可检查）
* 谨防在修改时破坏接口的抽象
* 不要添加与接口抽象不一致的公用成员
* 同时考虑抽象性和内聚性

良好的封装

* 尽可能地限制类和成员的可访问性
* 不要公开暴露成员数据
* 避免把私用的实现细节放入类的接口中
* 不要对类的使用者做出任何假设
* 避免使用友元类
* 不要因为一个子程序仅使用公用子程序，就把它归入公开接口
* 让阅读代码比编写代码更方便
* 要格外警惕从语义上破坏封装性
* 留意过于紧密的耦合关系

### 6.3 有关设计和实现的问题

包含：有一个的关系 has a

* 通过包含来实现有一个的关系
* 在万不得已时通过private继承来实现有个的关系
* 警惕有超过7个数据成员的类

继承：是一个的关系 is a

* 用public继承来实现是一个的关系
* 要么使用继承并进行详细说明，要么就不要用它
* 遵循Liskov替换原则
* 确保只继承需要继承的部分
* 不要覆盖一个不可覆盖的成员函数
* 把共用的接口、数据以操作放到继承树中尽可能高的位置
* 只有一个实例的类是值得怀疑的
* 只有一个派生类的基类也值得怀疑
* 派生类覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑
* 避免让继承体系过深
* 尽量使用多态，避免大量的类型检查
* 让所有的数据都是private

多重继承

* 太复杂，一般不建议使用
* mixins语义可以使用f

总的来说，继承要慎用，因为它一定程度上有悖于控制复杂性的基本理念。

成员函数和数据成员

* 让类中子程序的数量尽可能少
* 禁止隐式地产生你不需要地成员函数和运算符（可以更改默认行为，比如让其private）
* 减少类所调用的不同子程序的数量
* 对其他类的子程序的间接调用要尽可能少（A可以调用A创建的对象B的子程序）
* 一般来说，应尽量减少类和类之间相互合作的范围

构造函数：

* 如果可能，应该在所有的构造函数中初始化所有的数据成员（类似pycharm的IDE往往会有警告）
* 用私用构造函数来强制实现单件属性
* 优先采用深层复本，除非论证可行，才采用浅层复本

### 6.4 创建类的原因

* 为现实世界中的对象建模
* 为抽象的对象建模
* 降低复杂度
* 隔离复杂度
* 隐藏实现细节
* 限制变动的影响范围
* 隐藏全局数据
* 让参数传递更顺畅
* 建立中心控制点
* 让代码更易于重用
* 为程序族作计划
* 把相关操作包装到一起
* 实现某种特定的重构

**应该避免的类**

* 避免创建万能类
* 消除无关紧要的类
* 避免用动词命名的类

### 6.5 与具体编程语言相关的问题

不同语言在实现类的方法上有很多差别。比如类的覆盖。

### 6.6 超越类：包

如果语言不支持包，可以自己预定实现，几个关键点：

* 用于区分“共用的类”和“某个包私用的类”的命名规则
* 为了区分每个类所属的包而定制的命名规则和/或代码组织规则（即项目结构）
* 固定什么包可以用其它什么包的规则，包框是否可以用继承和/或包含等

## 第7章 高质量的子程序

### 7.1 创建子程序的正当理由

* 降低复杂度
* 引入中间的、易懂的抽象
* 避免代码重复
* 支持子类化
* 隐藏顺序
* 隐藏指针操作
* 提高可移植性
* 简化复杂的逻辑判断
* 改善性能（只需要在一个地方优化）

即使很简单的逻辑，如果能提高可读性，也要考虑写出子程序。

### 7.2 在子程序层上设计

**内聚性**

* 功能的内聚性：一个程序仅执行一项操作

不太理想的内聚性

* 顺序上的内聚性：子程序内包含有需要按特定顺序执行的操作，这些步骤需要共享数据，而且只有在全部执行完毕后才完成了一项完整的功能。
* 通信上的内聚性：一个子程序中的不同操作使用了同样的数据，但不存在其它任何联系。
* 临时的内聚性：含有一些因为需要同时执行才放到一起的操作的子程序。（可做作为组织者）

不可取的内聚性：

* 过程上的内聚性：一个子程序中的操作是按特定的顺序进行的。
* 逻辑上的内聚性：若干操作被放入同一个子程序中，通过传入的控制标志选择执行其中的一项操作。
* 巧合的内聚性：子程序中的各个操作之间没有任何可以看到的关联。

### 7.3 好的子程序的名字

* 描述子程序所做的所有事情
* 避免使用无意义的、模糊或表述不清的动词
* 不要仅通过数字来形成不同的子程序名字
* 根据需要确定子程序的长度
* 给函数命名时要对返回值有所描述
* 给过程起名时使用语气强烈的动词加宾语的形式
* 准确使用对仗词
* 为常用操作确立命名规则

### 7.4 子程序可以写多长

总的来说，没有必要刻意去限制子程序的长度，而应该去考虑的是内聚性等复杂度事项，不过一般这样考虑了，子程序的长度不太可能超过200行。

### 7.5 如何使用子程序参数

减少接口错误的指导原则：

* 按照输入-修改-输出的顺序排列参数
* 考虑自己创建in和out关键字
* 如果几个子程序都用了类似的一些参数，应该让这些参数的排列顺序保持一致
* 使用所有的参数
* 把状态或出错变量放在最后
* 不要把子程序的参数用作工作变量
* 在接口中对参数的假定加以说明（注释、断言）
* 把子程序的个数限制在大约7个以内
* 考虑对参数采用某种表示输入、修改、输出的命名规则
* 为子程序传递用以维持其接口抽象的变量或对象
* 使用具名参数
* 确保实际参数与形式参数相匹配（类型要匹配）

### 7.6 使用函数时要特别考虑的问题

如果一个子程序的主要用途就是返回由其名字所指明的返回值，那么就应该使用函数，否则应该使用过程。对于返回值：

* 检查所有可能的返回路径
* 不要返回指向局部数据的引用或指针

### 7.7 宏子程序和内联子程序

* 把表达式整个包含在括号内
* 把含有多条语句的宏用大括号括起来
* 用给子程序命名的方法来给展开后代码形同子程序的宏命名，以便在需要时可以用子程序来替换宏

可以用来替代宏的方案：

* const
* inline（也需要节制使用）
* enum
* typedef

